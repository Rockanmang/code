# 前端开发指南

## 🎯 快速开始

### 1. 基本设置

```javascript
// API配置
const API_BASE_URL = 'http://localhost:8000';

// 创建API客户端
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
    this.token = localStorage.getItem('access_token');
  }

  // 设置认证令牌
  setToken(token) {
    this.token = token;
    localStorage.setItem('access_token', token);
  }

  // 清除令牌
  clearToken() {
    this.token = null;
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
  }

  // 通用请求方法
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    };

    // 添加认证头
    if (this.token && !config.headers.Authorization) {
      config.headers.Authorization = `Bearer ${this.token}`;
    }

    try {
      const response = await fetch(url, config);
      
      // 处理401错误（token过期）
      if (response.status === 401) {
        await this.handleTokenExpiry();
        return null;
      }

      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.detail || `HTTP ${response.status}`);
      }

      return data;
    } catch (error) {
      console.error('API请求失败:', error);
      throw error;
    }
  }

  // 处理token过期
  async handleTokenExpiry() {
    const refreshToken = localStorage.getItem('refresh_token');
    
    if (refreshToken) {
      try {
        const response = await fetch(`${this.baseURL}/api/auth/refresh`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ refresh_token: refreshToken })
        });

        if (response.ok) {
          const { access_token } = await response.json();
          this.setToken(access_token);
          return true;
        }
      } catch (error) {
        console.error('Token刷新失败:', error);
      }
    }

    // 刷新失败，清除token并重定向到登录页
    this.clearToken();
    window.location.href = '/login';
    return false;
  }
}

// 创建全局API客户端实例
const api = new APIClient(API_BASE_URL);
```

### 2. 用户认证

```javascript
// 用户认证相关API
class AuthAPI {
  // 手机号注册
  static async register(userData) {
    return api.request('/api/auth/register', {
      method: 'POST',
      body: JSON.stringify(userData)
    });
  }

  // 手机号登录
  static async loginWithPhone(phone_number, password) {
    const response = await api.request('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify({ phone_number, password })
    });

    if (response?.access_token) {
      api.setToken(response.access_token);
      if (response.refresh_token) {
        localStorage.setItem('refresh_token', response.refresh_token);
      }
    }

    return response;
  }

  // 传统用户名登录（兼容）
  static async loginWithUsername(username, password) {
    const formData = new FormData();
    formData.append('username', username);
    formData.append('password', password);

    const response = await fetch(`${API_BASE_URL}/login`, {
      method: 'POST',
      body: formData
    });

    const data = await response.json();
    
    if (response.ok && data.access_token) {
      api.setToken(data.access_token);
    } else {
      throw new Error(data.detail || '登录失败');
    }

    return data;
  }

  // 登出
  static logout() {
    api.clearToken();
    window.location.href = '/login';
  }

  // 获取当前用户信息
  static async getCurrentUser() {
    return api.request('/api/user/me');
  }
}
```

### 3. 用户界面示例

```jsx
// React登录组件示例
import React, { useState } from 'react';

const LoginForm = () => {
  const [formData, setFormData] = useState({
    phone_number: '',
    password: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');

  const handleLogin = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      // 首先尝试手机号登录
      await AuthAPI.loginWithPhone(formData.phone_number, formData.password);
      
      // 登录成功，重定向
      window.location.href = '/dashboard';
    } catch (error) {
      // 如果手机号登录失败，可以尝试用户名登录
      try {
        await AuthAPI.loginWithUsername(formData.phone_number, formData.password);
        window.location.href = '/dashboard';
      } catch (secondError) {
        setError('登录失败：' + secondError.message);
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleLogin}>
      <div>
        <label>手机号/用户名:</label>
        <input
          type="text"
          value={formData.phone_number}
          onChange={(e) => setFormData({...formData, phone_number: e.target.value})}
          placeholder="请输入手机号或用户名"
          required
        />
      </div>
      
      <div>
        <label>密码:</label>
        <input
          type="password"
          value={formData.password}
          onChange={(e) => setFormData({...formData, password: e.target.value})}
          required
        />
      </div>

      {error && <div style={{color: 'red'}}>{error}</div>}
      
      <button type="submit" disabled={loading}>
        {loading ? '登录中...' : '登录'}
      </button>
    </form>
  );
};
```

## 📋 研究组管理

```javascript
// 研究组相关API
class GroupAPI {
  // 获取用户研究组
  static async getUserGroups() {
    return api.request('/user/groups');
  }

  // 创建研究组
  static async createGroup(groupData) {
    const params = new URLSearchParams(groupData);
    return api.request(`/groups/create?${params}`, {
      method: 'POST'
    });
  }

  // 加入研究组
  static async joinGroup(group_id, invitation_code) {
    const params = new URLSearchParams({ group_id, invitation_code });
    return api.request(`/groups/join?${params}`, {
      method: 'POST'
    });
  }
}

// React研究组组件示例
const GroupManager = () => {
  const [groups, setGroups] = useState([]);
  const [showCreateForm, setShowCreateForm] = useState(false);

  useEffect(() => {
    loadUserGroups();
  }, []);

  const loadUserGroups = async () => {
    try {
      const response = await GroupAPI.getUserGroups();
      setGroups(response.groups || []);
    } catch (error) {
      console.error('加载研究组失败:', error);
    }
  };

  const handleCreateGroup = async (groupData) => {
    try {
      const response = await GroupAPI.createGroup(groupData);
      alert('研究组创建成功！邀请码：' + response.invitation_code);
      loadUserGroups(); // 重新加载
      setShowCreateForm(false);
    } catch (error) {
      alert('创建失败：' + error.message);
    }
  };

  return (
    <div>
      <h2>我的研究组</h2>
      
      <button onClick={() => setShowCreateForm(true)}>
        创建研究组
      </button>

      <div>
        {groups.map(group => (
          <div key={group.id} style={{border: '1px solid #ccc', margin: '10px', padding: '10px'}}>
            <h3>{group.name}</h3>
            <p>机构：{group.institution}</p>
            <p>领域：{group.research_area}</p>
            <p>邀请码：{group.invitation_code}</p>
          </div>
        ))}
      </div>

      {showCreateForm && (
        <CreateGroupForm 
          onSubmit={handleCreateGroup}
          onCancel={() => setShowCreateForm(false)}
        />
      )}
    </div>
  );
};
```

## 📚 文献管理

```javascript
// 文献相关API
class LiteratureAPI {
  // 获取研究组文献列表
  static async getGroupLiterature(groupId) {
    return api.request(`/literature/public/${groupId}`);
  }

  // 获取文献详情
  static async getLiteratureDetail(literatureId) {
    return api.request(`/literature/detail/${literatureId}`);
  }

  // 上传文献
  static async uploadLiterature(file, groupId, title = '') {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('group_id', groupId);
    if (title) formData.append('title', title);

    return api.request('/literature/upload', {
      method: 'POST',
      headers: {
        // 不设置Content-Type，让浏览器自动设置
        'Authorization': `Bearer ${api.token}`
      },
      body: formData
    });
  }

  // 获取文献文件URL
  static getFileURL(literatureId) {
    return `${API_BASE_URL}/literature/view/file/${literatureId}`;
  }
}

// React文献上传组件
const LiteratureUpload = ({ groupId, onUploadSuccess }) => {
  const [uploading, setUploading] = useState(false);
  const [selectedFile, setSelectedFile] = useState(null);
  const [title, setTitle] = useState('');

  const handleFileChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      // 检查文件类型
      const allowedTypes = ['application/pdf', 'application/msword', 
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'];
      
      if (!allowedTypes.includes(file.type)) {
        alert('只支持PDF和Word文档');
        return;
      }

      // 检查文件大小（50MB）
      if (file.size > 50 * 1024 * 1024) {
        alert('文件大小不能超过50MB');
        return;
      }

      setSelectedFile(file);
      // 如果没有设置标题，使用文件名
      if (!title) {
        setTitle(file.name.split('.')[0]);
      }
    }
  };

  const handleUpload = async () => {
    if (!selectedFile) {
      alert('请选择文件');
      return;
    }

    setUploading(true);
    try {
      const response = await LiteratureAPI.uploadLiterature(
        selectedFile, 
        groupId, 
        title
      );
      
      alert('上传成功：' + response.title);
      onUploadSuccess && onUploadSuccess(response);
      
      // 重置表单
      setSelectedFile(null);
      setTitle('');
    } catch (error) {
      alert('上传失败：' + error.message);
    } finally {
      setUploading(false);
    }
  };

  return (
    <div>
      <h3>上传文献</h3>
      
      <div>
        <label>选择文件:</label>
        <input
          type="file"
          accept=".pdf,.doc,.docx"
          onChange={handleFileChange}
          disabled={uploading}
        />
      </div>

      {selectedFile && (
        <div>
          <label>标题:</label>
          <input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder="文献标题"
          />
        </div>
      )}

      <button 
        onClick={handleUpload}
        disabled={!selectedFile || uploading}
      >
        {uploading ? '上传中...' : '上传'}
      </button>
    </div>
  );
};

// 文献列表组件
const LiteratureList = ({ groupId }) => {
  const [literature, setLiterature] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadLiterature();
  }, [groupId]);

  const loadLiterature = async () => {
    try {
      const response = await LiteratureAPI.getGroupLiterature(groupId);
      setLiterature(response.literature || []);
    } catch (error) {
      console.error('加载文献失败:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleFileView = (literatureId) => {
    // 在新窗口打开文件
    const fileURL = LiteratureAPI.getFileURL(literatureId);
    window.open(fileURL, '_blank');
  };

  if (loading) return <div>加载中...</div>;

  return (
    <div>
      <h3>文献列表</h3>
      
      {literature.length === 0 ? (
        <p>暂无文献</p>
      ) : (
        <div>
          {literature.map(lit => (
            <div key={lit.id} style={{border: '1px solid #ddd', margin: '10px', padding: '10px'}}>
              <h4>{lit.title}</h4>
              <p>文件名: {lit.filename}</p>
              <p>大小: {(lit.file_size / 1024 / 1024).toFixed(2)} MB</p>
              <p>上传时间: {new Date(lit.upload_time).toLocaleString()}</p>
              <p>上传者: {lit.uploaded_by}</p>
              
              <button onClick={() => handleFileView(lit.id)}>
                查看文件
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

## 🤖 AI助手

```javascript
// AI相关API
class AIAPI {
  // 获取预设问题
  static async getPresetQuestions(literatureId) {
    return api.request(`/ai/preset-questions/${literatureId}`);
  }

  // AI问答
  static async askQuestion(question, literatureId, options = {}) {
    const requestData = {
      question,
      literature_id: literatureId,
      max_sources: options.maxSources || 5,
      include_history: options.includeHistory || false,
      ...options
    };

    return api.request('/ai/ask', {
      method: 'POST',
      body: JSON.stringify(requestData)
    });
  }
}

// React AI聊天组件
const AIChat = ({ literatureId }) => {
  const [messages, setMessages] = useState([]);
  const [inputQuestion, setInputQuestion] = useState('');
  const [loading, setLoading] = useState(false);
  const [presetQuestions, setPresetQuestions] = useState([]);

  useEffect(() => {
    loadPresetQuestions();
  }, [literatureId]);

  const loadPresetQuestions = async () => {
    try {
      const response = await AIAPI.getPresetQuestions(literatureId);
      setPresetQuestions(response.questions || []);
    } catch (error) {
      console.error('加载预设问题失败:', error);
    }
  };

  const askQuestion = async (question) => {
    if (!question.trim()) return;

    // 添加用户问题到消息列表
    const userMessage = { type: 'user', content: question, timestamp: new Date() };
    setMessages(prev => [...prev, userMessage]);
    setInputQuestion('');
    setLoading(true);

    try {
      const response = await AIAPI.askQuestion(question, literatureId);
      
      // 添加AI回答到消息列表
      const aiMessage = {
        type: 'ai',
        content: response.answer,
        sources: response.sources,
        confidence: response.confidence,
        timestamp: new Date()
      };
      
      setMessages(prev => [...prev, aiMessage]);
    } catch (error) {
      // 添加错误消息
      const errorMessage = {
        type: 'error',
        content: '抱歉，AI服务暂时不可用：' + error.message,
        timestamp: new Date()
      };
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setLoading(false);
    }
  };

  const handlePresetQuestion = (question) => {
    askQuestion(question);
  };

  return (
    <div style={{maxWidth: '600px', margin: '0 auto'}}>
      <h3>AI助手</h3>
      
      {/* 预设问题 */}
      {presetQuestions.length > 0 && (
        <div style={{marginBottom: '20px'}}>
          <h4>预设问题:</h4>
          {presetQuestions.map((question, index) => (
            <button
              key={index}
              onClick={() => handlePresetQuestion(question)}
              style={{
                display: 'block',
                width: '100%',
                margin: '5px 0',
                padding: '10px',
                textAlign: 'left',
                border: '1px solid #ddd',
                background: '#f9f9f9',
                cursor: 'pointer'
              }}
            >
              {question}
            </button>
          ))}
        </div>
      )}

      {/* 聊天消息 */}
      <div style={{
        height: '400px',
        overflowY: 'scroll',
        border: '1px solid #ddd',
        padding: '10px',
        marginBottom: '10px'
      }}>
        {messages.map((message, index) => (
          <div key={index} style={{
            marginBottom: '15px',
            padding: '10px',
            borderRadius: '8px',
            backgroundColor: message.type === 'user' ? '#e3f2fd' : 
                           message.type === 'error' ? '#ffebee' : '#f5f5f5'
          }}>
            <div style={{fontWeight: 'bold', marginBottom: '5px'}}>
              {message.type === 'user' ? '您' : 
               message.type === 'error' ? '错误' : 'AI助手'}
            </div>
            <div>{message.content}</div>
            
            {/* 显示AI回答的来源 */}
            {message.sources && message.sources.length > 0 && (
              <div style={{marginTop: '10px', fontSize: '0.9em', color: '#666'}}>
                <strong>参考来源:</strong>
                {message.sources.map((source, idx) => (
                  <div key={idx} style={{marginLeft: '10px', marginTop: '5px'}}>
                    • {source.content.substring(0, 100)}...
                    {source.page && ` (第${source.page}页)`}
                  </div>
                ))}
              </div>
            )}
            
            <div style={{fontSize: '0.8em', color: '#999', marginTop: '5px'}}>
              {message.timestamp.toLocaleTimeString()}
            </div>
          </div>
        ))}
        
        {loading && (
          <div style={{textAlign: 'center', color: '#666'}}>
            AI正在思考中...
          </div>
        )}
      </div>

      {/* 输入框 */}
      <div style={{display: 'flex'}}>
        <input
          type="text"
          value={inputQuestion}
          onChange={(e) => setInputQuestion(e.target.value)}
          placeholder="输入您的问题..."
          style={{flex: 1, padding: '10px', marginRight: '10px'}}
          onKeyPress={(e) => e.key === 'Enter' && askQuestion(inputQuestion)}
          disabled={loading}
        />
        <button
          onClick={() => askQuestion(inputQuestion)}
          disabled={loading || !inputQuestion.trim()}
          style={{padding: '10px 20px'}}
        >
          发送
        </button>
      </div>
    </div>
  );
};
```

## 🔧 最佳实践

### 1. 错误处理策略

```javascript
// 全局错误处理器
class ErrorHandler {
  static handle(error, context = '') {
    console.error(`[${context}] 错误:`, error);
    
    // 根据错误类型进行不同处理
    if (error.message.includes('401')) {
      // 未认证，重定向到登录页
      AuthAPI.logout();
    } else if (error.message.includes('403')) {
      // 权限不足
      alert('权限不足，请联系管理员');
    } else if (error.message.includes('413')) {
      // 文件过大
      alert('文件大小超过限制(50MB)');
    } else {
      // 其他错误
      alert('操作失败：' + error.message);
    }
  }
}

// 在组件中使用
try {
  await SomeAPI.someMethod();
} catch (error) {
  ErrorHandler.handle(error, '文献上传');
}
```

### 2. 加载状态管理

```javascript
// 自定义Hook管理加载状态
const useAsyncOperation = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const execute = async (asyncFn) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await asyncFn();
      return result;
    } catch (err) {
      setError(err);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  return { loading, error, execute };
};

// 使用示例
const MyComponent = () => {
  const { loading, error, execute } = useAsyncOperation();

  const handleUpload = async () => {
    await execute(() => LiteratureAPI.uploadLiterature(file, groupId));
  };

  return (
    <div>
      {loading && <div>加载中...</div>}
      {error && <div>错误: {error.message}</div>}
      <button onClick={handleUpload} disabled={loading}>
        上传
      </button>
    </div>
  );
};
```

### 3. 数据缓存策略

```javascript
// 简单的内存缓存
class Cache {
  static data = new Map();
  static timeouts = new Map();

  static set(key, value, ttl = 300000) { // 默认5分钟
    this.data.set(key, value);
    
    // 清除之前的超时
    if (this.timeouts.has(key)) {
      clearTimeout(this.timeouts.get(key));
    }
    
    // 设置新的超时
    const timeout = setTimeout(() => {
      this.data.delete(key);
      this.timeouts.delete(key);
    }, ttl);
    
    this.timeouts.set(key, timeout);
  }

  static get(key) {
    return this.data.get(key);
  }

  static has(key) {
    return this.data.has(key);
  }

  static clear() {
    this.data.clear();
    this.timeouts.forEach(timeout => clearTimeout(timeout));
    this.timeouts.clear();
  }
}

// 带缓存的API调用
class CachedAPI {
  static async getGroupLiterature(groupId) {
    const cacheKey = `literature_${groupId}`;
    
    if (Cache.has(cacheKey)) {
      return Cache.get(cacheKey);
    }
    
    const data = await LiteratureAPI.getGroupLiterature(groupId);
    Cache.set(cacheKey, data);
    return data;
  }

  // 清除相关缓存
  static invalidateGroupCache(groupId) {
    Cache.data.delete(`literature_${groupId}`);
  }
}
```

## 🆕 新增功能示例

### 1. 文献高级管理

```javascript
// 文献高级管理API
class LiteratureAdvancedAPI {
  // 软删除文献
  static async deleteLiterature(literatureId, reason = '') {
    const params = new URLSearchParams();
    if (reason) params.append('reason', reason);
    
    return api.request(`/literature/${literatureId}?${params}`, {
      method: 'DELETE'
    });
  }

  // 恢复已删除文献
  static async restoreLiterature(literatureId) {
    return api.request(`/literature/${literatureId}/restore`, {
      method: 'POST'
    });
  }

  // 获取已删除文献列表
  static async getDeletedLiterature(groupId) {
    return api.request(`/literature/deleted/${groupId}`);
  }

  // 获取文献统计信息
  static async getLiteratureStats(groupId) {
    return api.request(`/literature/stats/${groupId}`);
  }
}

// React文献管理组件示例
const LiteratureManager = ({ groupId }) => {
  const [literature, setLiterature] = useState([]);
  const [deletedLiterature, setDeletedLiterature] = useState([]);
  const [stats, setStats] = useState(null);
  const [showDeleted, setShowDeleted] = useState(false);

  // 删除文献
  const handleDelete = async (literatureId, reason) => {
    try {
      await LiteratureAdvancedAPI.deleteLiterature(literatureId, reason);
      alert('文献已删除');
      loadLiterature();
      loadDeletedLiterature();
    } catch (error) {
      alert('删除失败：' + error.message);
    }
  };

  // 恢复文献
  const handleRestore = async (literatureId) => {
    try {
      await LiteratureAdvancedAPI.restoreLiterature(literatureId);
      alert('文献已恢复');
      loadLiterature();
      loadDeletedLiterature();
    } catch (error) {
      alert('恢复失败：' + error.message);
    }
  };

  const loadDeletedLiterature = async () => {
    try {
      const response = await LiteratureAdvancedAPI.getDeletedLiterature(groupId);
      setDeletedLiterature(response.deleted_literature || []);
    } catch (error) {
      console.error('加载已删除文献失败:', error);
    }
  };

  const loadStats = async () => {
    try {
      const response = await LiteratureAdvancedAPI.getLiteratureStats(groupId);
      setStats(response.statistics);
    } catch (error) {
      console.error('加载统计信息失败:', error);
    }
  };

  return (
    <div>
      {/* 统计信息 */}
      {stats && (
        <div style={{background: '#f5f5f5', padding: '10px', margin: '10px 0'}}>
          <h4>文献统计</h4>
          <p>活跃文献: {stats.active_count}</p>
          <p>已删除: {stats.deleted_count}</p>
          <p>总大小: {(stats.total_size / 1024 / 1024).toFixed(2)} MB</p>
        </div>
      )}

      {/* 切换显示 */}
      <div>
        <button onClick={() => setShowDeleted(false)}>活跃文献</button>
        <button onClick={() => setShowDeleted(true)}>回收站</button>
      </div>

      {/* 文献列表 */}
      {!showDeleted ? (
        <div>
          {literature.map(lit => (
            <div key={lit.id}>
              <h4>{lit.title}</h4>
              <button onClick={() => handleDelete(lit.id, '用户删除')}>
                删除
              </button>
            </div>
          ))}
        </div>
      ) : (
        <div>
          {deletedLiterature.map(lit => (
            <div key={lit.id}>
              <h4>{lit.title}</h4>
              <p>删除时间: {new Date(lit.deleted_at).toLocaleString()}</p>
              <p>删除原因: {lit.delete_reason}</p>
              <button onClick={() => handleRestore(lit.id)}>
                恢复
              </button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

### 2. 对话管理

```javascript
// 对话管理API
class ConversationAPI {
  // 获取用户会话列表
  static async getUserSessions(literatureId = null, limit = 20, offset = 0) {
    const params = new URLSearchParams({ limit, offset });
    if (literatureId) params.append('literature_id', literatureId);
    
    return api.request(`/ai/sessions?${params}`);
  }

  // 获取对话历史
  static async getConversationHistory(sessionId, includeFullContent = true, limit = 50) {
    const params = new URLSearchParams({
      include_full_content: includeFullContent,
      limit
    });
    
    return api.request(`/ai/conversation/${sessionId}?${params}`);
  }

  // 删除对话会话
  static async deleteSession(sessionId) {
    return api.request(`/ai/conversation/${sessionId}`, {
      method: 'DELETE'
    });
  }

  // 提交反馈
  static async submitFeedback(turnId, rating, feedback = '') {
    return api.request('/ai/feedback', {
      method: 'POST',
      body: JSON.stringify({
        turn_id: turnId,
        rating,
        feedback
      })
    });
  }
}

// React对话历史组件
const ConversationHistory = () => {
  const [sessions, setSessions] = useState([]);
  const [selectedSession, setSelectedSession] = useState(null);
  const [conversationTurns, setConversationTurns] = useState([]);

  useEffect(() => {
    loadSessions();
  }, []);

  const loadSessions = async () => {
    try {
      const response = await ConversationAPI.getUserSessions();
      setSessions(response.sessions || []);
    } catch (error) {
      console.error('加载会话列表失败:', error);
    }
  };

  const loadConversation = async (sessionId) => {
    try {
      const response = await ConversationAPI.getConversationHistory(sessionId);
      setConversationTurns(response.conversation_turns || []);
      setSelectedSession(sessionId);
    } catch (error) {
      console.error('加载对话历史失败:', error);
    }
  };

  const handleDeleteSession = async (sessionId) => {
    if (window.confirm('确定要删除这个对话会话吗？')) {
      try {
        await ConversationAPI.deleteSession(sessionId);
        loadSessions();
        if (selectedSession === sessionId) {
          setSelectedSession(null);
          setConversationTurns([]);
        }
      } catch (error) {
        alert('删除失败：' + error.message);
      }
    }
  };

  const handleFeedback = async (turnId, rating) => {
    try {
      await ConversationAPI.submitFeedback(turnId, rating);
      alert('反馈提交成功');
    } catch (error) {
      alert('反馈提交失败：' + error.message);
    }
  };

  return (
    <div style={{display: 'flex', height: '600px'}}>
      {/* 会话列表 */}
      <div style={{width: '300px', borderRight: '1px solid #ddd', padding: '10px'}}>
        <h3>对话历史</h3>
        {sessions.map(session => (
          <div 
            key={session.session_id}
            style={{
              border: '1px solid #eee',
              margin: '5px 0',
              padding: '10px',
              cursor: 'pointer',
              backgroundColor: selectedSession === session.session_id ? '#e3f2fd' : 'white'
            }}
            onClick={() => loadConversation(session.session_id)}
          >
            <div style={{fontWeight: 'bold'}}>{session.literature_title}</div>
            <div style={{fontSize: '0.9em', color: '#666'}}>
              {new Date(session.last_activity).toLocaleString()}
            </div>
            <div style={{fontSize: '0.8em', color: '#999'}}>
              {session.turn_count} 轮对话
            </div>
            <button 
              onClick={(e) => {
                e.stopPropagation();
                handleDeleteSession(session.session_id);
              }}
              style={{marginTop: '5px', fontSize: '0.8em'}}
            >
              删除
            </button>
          </div>
        ))}
      </div>

      {/* 对话详情 */}
      <div style={{flex: 1, padding: '10px'}}>
        {selectedSession ? (
          <div>
            <h3>对话详情</h3>
            {conversationTurns.map(turn => (
              <div key={turn.turn_id} style={{marginBottom: '20px'}}>
                <div style={{
                  background: '#e3f2fd',
                  padding: '10px',
                  borderRadius: '8px',
                  marginBottom: '5px'
                }}>
                  <strong>问题:</strong> {turn.question}
                </div>
                <div style={{
                  background: '#f5f5f5',
                  padding: '10px',
                  borderRadius: '8px',
                  marginBottom: '10px'
                }}>
                  <strong>回答:</strong> {turn.answer}
                  <div style={{fontSize: '0.8em', color: '#666', marginTop: '5px'}}>
                    置信度: {(turn.confidence * 100).toFixed(1)}% | 
                    处理时间: {turn.processing_time}s
                  </div>
                </div>
                <div>
                  <span>评分: </span>
                  {[1,2,3,4,5].map(rating => (
                    <button
                      key={rating}
                      onClick={() => handleFeedback(turn.turn_id, rating)}
                      style={{
                        background: turn.user_rating === rating ? '#2196F3' : '#eee',
                        color: turn.user_rating === rating ? 'white' : 'black',
                        border: 'none',
                        padding: '2px 6px',
                        margin: '0 2px',
                        borderRadius: '3px',
                        cursor: 'pointer'
                      }}
                    >
                      {rating}
                    </button>
                  ))}
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div>请选择一个对话会话查看详情</div>
        )}
      </div>
    </div>
  );
};
```

### 3. 缓存管理

```javascript
// 缓存管理API
class CacheAPI {
  // 获取缓存统计
  static async getCacheStats() {
    return api.request('/admin/cache/stats', {
      headers: {} // 不需要认证
    });
  }

  // 缓存健康检查
  static async getCacheHealth() {
    return api.request('/admin/cache/health', {
      headers: {}
    });
  }

  // 清理缓存
  static async clearCache(cacheType = 'all') {
    const params = new URLSearchParams({ cache_type: cacheType });
    return api.request(`/admin/cache/clear?${params}`, {
      method: 'POST',
      headers: {}
    });
  }

  // 预热缓存
  static async warmCache(literatureIds, cacheTypes) {
    return api.request('/admin/cache/warm', {
      method: 'POST',
      headers: {},
      body: JSON.stringify({
        literature_ids: literatureIds,
        cache_types: cacheTypes
      })
    });
  }

  // 性能测试
  static async benchmarkCache() {
    return api.request('/admin/cache/benchmark', {
      headers: {}
    });
  }
}

// React缓存管理组件
const CacheManager = () => {
  const [stats, setStats] = useState(null);
  const [health, setHealth] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    loadCacheInfo();
  }, []);

  const loadCacheInfo = async () => {
    try {
      const [statsResponse, healthResponse] = await Promise.all([
        CacheAPI.getCacheStats(),
        CacheAPI.getCacheHealth()
      ]);
      setStats(statsResponse.data);
      setHealth(healthResponse.data);
    } catch (error) {
      console.error('加载缓存信息失败:', error);
    }
  };

  const handleClearCache = async (cacheType) => {
    setLoading(true);
    try {
      await CacheAPI.clearCache(cacheType);
      alert(`${cacheType}缓存清理完成`);
      loadCacheInfo();
    } catch (error) {
      alert('缓存清理失败：' + error.message);
    } finally {
      setLoading(false);
    }
  };

  const handleWarmCache = async () => {
    setLoading(true);
    try {
      // 预热当前可见的文献
      await CacheAPI.warmCache(['current-literature-id'], ['embedding', 'chunk']);
      alert('缓存预热完成');
      loadCacheInfo();
    } catch (error) {
      alert('缓存预热失败：' + error.message);
    } finally {
      setLoading(false);
    }
  };

  const handleBenchmark = async () => {
    setLoading(true);
    try {
      const result = await CacheAPI.benchmarkCache();
      alert('性能测试完成，请查看控制台');
      console.log('缓存性能测试结果:', result);
    } catch (error) {
      alert('性能测试失败：' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <h2>缓存管理</h2>
      
      {/* 健康状态 */}
      {health && (
        <div style={{background: '#f5f5f5', padding: '15px', margin: '10px 0'}}>
          <h3>缓存健康状态</h3>
          <p>总体状态: <span style={{
            color: health.overall_status === 'healthy' ? 'green' : 'orange'
          }}>
            {health.overall_status}
          </span></p>
          <p>内存使用: {health.memory_usage?.total}</p>
          <p>使用率: {health.memory_usage?.usage_percentage}%</p>
        </div>
      )}

      {/* 缓存统计 */}
      {stats && (
        <div style={{background: '#fff', border: '1px solid #ddd', padding: '15px', margin: '10px 0'}}>
          <h3>缓存统计</h3>
          {Object.entries(stats).map(([cacheType, info]) => (
            <div key={cacheType} style={{marginBottom: '10px'}}>
              <h4>{cacheType.replace('_', ' ').toUpperCase()}</h4>
              <p>大小: {info.size} 条目</p>
              <p>命中率: {(info.hit_rate * 100).toFixed(1)}%</p>
              <p>内存使用: {info.memory_usage}</p>
              <button 
                onClick={() => handleClearCache(cacheType.replace('_cache', ''))}
                disabled={loading}
                style={{marginRight: '10px'}}
              >
                清理
              </button>
            </div>
          ))}
        </div>
      )}

      {/* 操作按钮 */}
      <div style={{margin: '20px 0'}}>
        <button 
          onClick={() => handleClearCache('all')}
          disabled={loading}
          style={{marginRight: '10px', backgroundColor: '#f44336', color: 'white'}}
        >
          清理所有缓存
        </button>
        <button 
          onClick={handleWarmCache}
          disabled={loading}
          style={{marginRight: '10px', backgroundColor: '#4CAF50', color: 'white'}}
        >
          预热缓存
        </button>
        <button 
          onClick={handleBenchmark}
          disabled={loading}
          style={{marginRight: '10px', backgroundColor: '#2196F3', color: 'white'}}
        >
          性能测试
        </button>
        <button 
          onClick={loadCacheInfo}
          disabled={loading}
        >
          刷新信息
        </button>
      </div>

      {loading && <div>操作中...</div>}
    </div>
  );
};
```

### 4. 管理员功能

```javascript
// 管理员功能API
class AdminAPI {
  // 获取存储统计
  static async getStorageStats() {
    return api.request('/admin/storage/stats');
  }

  // 清理存储
  static async cleanupStorage() {
    return api.request('/admin/storage/cleanup', {
      method: 'POST'
    });
  }

  // 获取AI服务统计
  static async getAIStats() {
    return api.request('/ai/stats');
  }
}

// React管理员控制台组件
const AdminDashboard = () => {
  const [storageStats, setStorageStats] = useState(null);
  const [aiStats, setAIStats] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    loadAllStats();
  }, []);

  const loadAllStats = async () => {
    try {
      const [storage, ai] = await Promise.all([
        AdminAPI.getStorageStats(),
        AdminAPI.getAIStats()
      ]);
      setStorageStats(storage);
      setAIStats(ai);
    } catch (error) {
      console.error('加载统计信息失败:', error);
    }
  };

  const handleStorageCleanup = async () => {
    if (window.confirm('确定要清理存储空间吗？这将删除空目录。')) {
      setLoading(true);
      try {
        const result = await AdminAPI.cleanupStorage();
        alert(`清理完成，删除了 ${result.count} 个空目录`);
        loadAllStats();
      } catch (error) {
        alert('存储清理失败：' + error.message);
      } finally {
        setLoading(false);
      }
    }
  };

  return (
    <div>
      <h2>管理员控制台</h2>
      
      {/* 存储统计 */}
      {storageStats && (
        <div style={{background: '#f5f5f5', padding: '15px', margin: '10px 0'}}>
          <h3>存储统计</h3>
          <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '10px'}}>
            <div>
              <h4>总体信息</h4>
              <p>研究组数: {storageStats.storage_statistics.total_groups}</p>
              <p>文件总数: {storageStats.storage_statistics.total_files}</p>
              <p>总大小: {(storageStats.storage_statistics.total_size / 1024 / 1024 / 1024).toFixed(2)} GB</p>
            </div>
            <div>
              <h4>文件类型分布</h4>
              {Object.entries(storageStats.storage_statistics.file_type_distribution).map(([type, count]) => (
                <p key={type}>{type.toUpperCase()}: {count} 个</p>
              ))}
            </div>
            <div>
              <h4>存储健康</h4>
              <p>磁盘使用率: {storageStats.storage_health.disk_usage}</p>
              <p>可用空间: {storageStats.storage_health.available_space}</p>
              <p>孤立文件: {storageStats.storage_health.orphaned_files}</p>
            </div>
          </div>
          <button 
            onClick={handleStorageCleanup}
            disabled={loading}
            style={{marginTop: '10px', backgroundColor: '#ff9800', color: 'white'}}
          >
            清理存储空间
          </button>
        </div>
      )}

      {/* AI服务统计 */}
      {aiStats && (
        <div style={{background: '#fff', border: '1px solid #ddd', padding: '15px', margin: '10px 0'}}>
          <h3>AI服务统计</h3>
          <div style={{display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '10px'}}>
            <div>
              <h4>查询统计</h4>
              <p>总查询数: {aiStats.total_queries}</p>
              <p>平均响应时间: {aiStats.average_response_time}s</p>
              <p>成功率: {(aiStats.success_rate * 100).toFixed(1)}%</p>
            </div>
            <div>
              <h4>热门问题</h4>
              {aiStats.popular_questions?.map((question, index) => (
                <p key={index}>{index + 1}. {question}</p>
              ))}
            </div>
            <div>
              <h4>每日使用量</h4>
              {Object.entries(aiStats.daily_usage || {}).slice(-7).map(([date, count]) => (
                <p key={date}>{date}: {count} 次</p>
              ))}
            </div>
          </div>
        </div>
      )}

      {loading && <div>处理中...</div>}
    </div>
  );
};
```

## 🔄 更新说明

### 新增功能总结

1. **文献高级管理**：
   - 软删除和恢复功能
   - 回收站管理
   - 文献统计信息

2. **对话管理**：
   - 会话历史查看
   - 对话记录管理
   - 用户反馈系统

3. **缓存管理**：
   - 缓存状态监控
   - 缓存清理和预热
   - 性能测试工具

4. **管理员功能**：
   - 存储空间管理
   - AI服务监控
   - 系统统计仪表板

### 使用建议

1. **权限控制**：管理员功能需要适当的权限验证
2. **错误处理**：所有API调用都应包含错误处理
3. **用户体验**：长时间操作要显示加载状态
4. **数据刷新**：操作完成后及时刷新相关数据

这些新功能为系统提供了更完整的管理能力，建议根据实际需求逐步实现和部署。

## ⚠️ 常见问题

### 1. CORS问题
如果遇到跨域问题，确保后端已正确配置CORS：

```javascript
// 如果需要，可以在开发环境使用代理
// package.json (for Create React App)
{
  "proxy": "http://localhost:8000"
}

// 或者在vite.config.js中配置
export default defineConfig({
  server: {
    proxy: {
      '/api': 'http://localhost:8000',
      '/health': 'http://localhost:8000',
      '/literature': 'http://localhost:8000'
    }
  }
});
```

### 2. 文件预览问题

```javascript
// PDF预览组件示例
import { Document, Page, pdfjs } from 'react-pdf';

// 设置PDF.js worker
pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.min.js`;

const PDFViewer = ({ literatureId }) => {
  const [file, setFile] = useState(null);
  const [numPages, setNumPages] = useState(null);
  const [pageNumber, setPageNumber] = useState(1);

  useEffect(() => {
    // 获取PDF文件
    const fileURL = LiteratureAPI.getFileURL(literatureId);
    setFile({
      url: fileURL,
      httpHeaders: {
        'Authorization': `Bearer ${api.token}`
      }
    });
  }, [literatureId]);

  const onDocumentLoadSuccess = ({ numPages }) => {
    setNumPages(numPages);
  };

  return (
    <div>
      <Document
        file={file}
        onLoadSuccess={onDocumentLoadSuccess}
      >
        <Page pageNumber={pageNumber} />
      </Document>
      
      <div>
        <button 
          disabled={pageNumber <= 1}
          onClick={() => setPageNumber(pageNumber - 1)}
        >
          上一页
        </button>
        
        <span>第 {pageNumber} 页，共 {numPages} 页</span>
        
        <button 
          disabled={pageNumber >= numPages}
          onClick={() => setPageNumber(pageNumber + 1)}
        >
          下一页
        </button>
      </div>
    </div>
  );
};
```

### 3. 移动端适配

```css
/* 响应式设计示例 */
.upload-form {
  padding: 20px;
}

@media (max-width: 768px) {
  .upload-form {
    padding: 10px;
  }
  
  .literature-grid {
    display: block;
  }
  
  .literature-item {
    margin-bottom: 10px;
  }
}

/* AI聊天界面移动端优化 */
.ai-chat {
  height: calc(100vh - 200px);
}

@media (max-width: 768px) {
  .ai-chat {
    height: calc(100vh - 150px);
  }
  
  .preset-questions button {
    font-size: 14px;
    padding: 8px;
  }
}
```

## 📱 移动端注意事项

1. **文件上传**: 移动端文件选择可能有限制，建议提供明确的文件类型说明
2. **PDF查看**: 考虑使用浏览器内置PDF查看器或第三方库
3. **AI聊天**: 在小屏幕上优化聊天界面布局
4. **网络状态**: 考虑网络不佳时的重试机制

## 🚀 部署建议

### 环境变量配置

```javascript
// 环境配置
const config = {
  development: {
    API_BASE_URL: 'http://localhost:8000'
  },
  production: {
    API_BASE_URL: 'https://your-api-domain.com'
  }
};

export const API_BASE_URL = config[process.env.NODE_ENV] || config.development;
```

### 生产环境优化

1. **API请求优化**: 使用防抖和节流
2. **图片懒加载**: 对于文献封面等
3. **代码分割**: 按路由分割代码
4. **缓存策略**: 合理使用浏览器缓存

这份开发指南应该能帮助前端团队快速上手API的使用。如有任何问题，请随时联系后端开发团队！ 