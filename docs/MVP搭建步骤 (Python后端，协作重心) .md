# MVP搭建步骤 (Python后端，协作重心)

**项目名称：** AI驱动协同文献管理系统MVP
**MVP目标：** 交付一个功能原型，展示用户认证、课题组创建/加入、公共文献上传/查看以及在共享文献背景下的核心AI问答功能。
**时间周期：** 7天 (开始日期：2025年5月21日 - 结束日期：2025年5月27日)

---

### MVP范围定义 (Python后端，协作重心)

为在7天内实现一个可演示的MVP并强调协作，我们将重点关注以下核心功能：

- **用户系统：** 账户创建和登录。
- **课题组管理：** 创建课题组，加入课题组。
- **文献管理（公共文献库）：** 上传PDF/Word/HTML文件到**公共课题组文献库**，以及查看文献（在线阅读器提供基本显示）。
- **AI助手：** 唤醒AI助手，并针对**当前查看的公共文献**进行AI问答。

**MVP范围外功能 (将在后续迭代中实现)：**

- 私人文献库。
- 退出课题组。
- 协作功能（批注、@成员、实时同步）。
- AI跨文献关联。
- 高级在线阅读器功能（高亮、缩放、目录跳转等）。
- 非功能性需求，如完整并发支持、国际化、除基本日志外的详细错误追踪。
- 课题组管理中的管理员功能。

---

### 详细7天工作计划 (Python后端，协作重心)

**技术栈概览：**

- **前端：** Next.js 14 (App Router), Shadcn/ui + TailwindCSS, Zustand, react-pdf
- **后端：** Python (FastAPI), SQLAlchemy (ORM), Pydantic, python-jose (JWT), passlib (密码哈希), PyPDF2/python-docx (文献解析), Uvicorn (ASGI服务器)
- **AI：** Langchain (Python), OpenAI API, ChromaDB (轻量级本地向量数据库，或考虑使用FAISS作为MVP，Pinecone/Weaviate作为未来选项)

**Day 1: 环境搭建 & 核心后端 (用户认证)**

- **目标：** 搭建开发环境，设置Next.js和FastAPI项目，实现用户注册和登录接口。
- **任务拆解与步骤：**
    1. **项目初始化 (前端 - Next.js):**
        - **第一步：创建Next.js项目。**
            - **作用：** 搭建前端应用骨架。
            - **步骤：** `npx create-next-app@latest my-literature-app --typescript --tailwind --eslint --app`。
            - **效果：** 生成一个基于Next.js App Router的TypeScript项目，集成了Tailwind CSS和ESLint。
        - **第二步：安装UI库。**
            - **作用：** 引入现代化UI组件，加速开发。
            - **步骤：** 按照Shadcn/ui官方文档初始化并添加 `button`, `input`, `form`, `card` 等组件。
            - **效果：** 可以在前端代码中使用 `shadcn/ui` 提供的组件。
        - **第三步：配置基本布局。**
            - **作用：** 为登录/注册页面提供统一的样式。
            - **步骤：** 在`app/layout.tsx`中设置基本的HTML和body结构，并创建 `app/(auth)/login` 和 `app/(auth)/register` 路由。
            - **效果：** 有了基本的页面结构和路由。
    2. **项目初始化 (后端 - Python FastAPI):**
        - **第一步：创建Python虚拟环境并安装FastAPI。**
            - **作用：** 隔离项目依赖，并引入Web框架。
            - **步骤：** `python -m venv venv` -> `source venv/bin/activate` (Linux/macOS) 或 `venv\Scripts\activate` (Windows) -> `pip install fastapi uvicorn[standard] python-jose[cryptography] passlib[bcrypt] psycopg2-binary sqlalchemy` (如果使用PostgreSQL，或 `sqlite3` 用于SQLite)。
            - **效果：** 拥有一个独立的Python环境，并安装了FastAPI及常用认证、数据库相关库。
        - **第二步：设置数据库 (SQLite for MVP)。**
            - **作用：** 提供数据存储层。
            - **步骤：** 使用SQLAlchemy定义User模型，包括 `id`, `username`, `phone_number`, `hashed_password`。在`main.py`或独立的`database.py`中配置SQLite数据库连接。
            - **效果：** 后端服务可以连接到数据库并定义了用户表结构。
        - **第三步：实现用户注册接口。**
            - **作用：** 允许新用户创建账户。
            - **步骤：** 在`main.py`中创建 `/auth/register` POST接口。接收Pydantic模型定义的 `username`, `phone_number`, `password`。使用 `passlib` 的 `bcrypt` 对密码进行哈希。检查 `phone_number` 是否已存在。将用户数据存储到数据库。
            - **效果：** 后端提供了用户注册功能，并对密码进行了安全处理。
        - **第四步：实现用户登录接口。**
            - **作用：** 允许注册用户登录。
            - **步骤：** 在`main.py`中创建 `/auth/login` POST接口。接收 `phone_number`, `password`。验证手机号和密码（通过 `bcrypt.verify`）。如果验证成功，使用 `python-jose` 生成JWT令牌。
            - **效果：** 后端提供了用户登录功能，并返回JWT令牌用于后续认证。
    3. **前端认证集成：**
        - **第一步：创建登录/注册表单组件。**
            - **作用：** 为用户提供输入界面。
            - **步骤：** 在 `app/(auth)/login/page.tsx` 和 `app/(auth)/register/page.tsx` 中使用Shadcn/ui的 `Form` 和 `Input` 组件构建表单。
            - **效果：** 页面上显示可交互的登录和注册表单。
        - **第二步：连接前端到后端API。**
            - **作用：** 使前端能够与后端进行数据交互。
            - **步骤：** 使用 `Workspace` 或 `axios` 在表单提交时调用FastAPI的 `/auth/register` 和 `/auth/login` 接口。处理响应，包括错误提示和成功跳转。成功登录后，将JWT令牌存储在 `localStorage` 或 `sessionStorage` 中。
            - **效果：** 用户可以成功注册和登录，并在登录后获得认证令牌。

**Day 2: 课题组管理 (创建 & 加入)**

- **目标：** 实现用户创建和加入课题组的功能。
- **任务拆解与步骤：**
    1. **数据库Schema扩展 (后端):**
        - **第一步：定义课题组模型。**
            - **作用：** 存储课题组信息。
            - **步骤：** 在SQLAlchemy中定义 `ResearchGroup` 模型，包含 `id` (UUID), `name`, `institution`, `description`, `research_area`, `invitation_code` (随机生成，唯一)。
            - **效果：** 数据库中有了课题组的表结构。
        - **第二步：定义用户-课题组关联模型。**
            - **作用：** 记录用户所属的课题组。
            - **步骤：** 定义 `UserResearchGroup` 关联表，包含 `user_id`, `group_id`。建立 `User` 和 `ResearchGroup` 之间的多对多关系。
            - **效果：** 可以记录哪个用户属于哪个课题组。
    2. **创建课题组接口 (后端):**
        - **第一步：实现 `/groups/create` POST接口。**
            - **作用：** 允许用户创建新课题组。
            - **步骤：** 接收 `name`, `institution`, `description`, `research_area`。生成一个唯一的 `invitation_code` (例如，8位随机字母数字组合)。将课题组信息存入数据库。将当前认证用户添加为该课题组的第一个成员。
            - **效果：** 成功创建课题组后，返回课题组ID和邀请码，并记录创建者为成员。
    3. **加入课题组接口 (后端):**
        - **第一步：实现 `/groups/join` POST接口。**
            - **作用：** 允许用户通过ID和邀请码加入课题组。
            - **步骤：** 接收 `group_id`, `invitation_code`。验证 `group_id` 和 `invitation_code` 是否匹配。检查当前认证用户是否已在该课题组。如果验证通过且未加入，将用户添加到 `UserResearchGroup` 关联表中。
            - **效果：** 用户可以成功加入课题组，如果ID或邀请码错误或已加入则返回相应错误信息。
    4. **前端课题组管理UI：**
        - **第一步：修改个人资料页面。**
            - **作用：** 显示课题组相关按钮。
            - **步骤：** 在用户登录后，在个人资料页面 (或一个独立页面) 显示 "创建课题组" 和 "加入课题组" 按钮。
            - **效果：** 用户能看到并点击创建/加入课题组的入口。
        - **第二步：创建/加入课题组表单和逻辑。**
            - **作用：** 提供输入界面并调用后端接口。
            - **步骤：** 为 "创建课题组" 和 "加入课题组" 按钮创建模态框或新页面，包含相应的表单字段。在提交时，调用后端 `/groups/create` 和 `/groups/join` 接口。成功后，更新前端状态，并在左侧目录栏动态添加 "公有文献库 (课题组名称)"。
            - **效果：** 用户可以成功创建或加入课题组，并在UI上看到课题组信息及公共文献库入口。

**Day 3: 公共文献库上传 & 存储**

- **目标：** 使课题组成员能够上传文献到其公共课题组文献库，包括文件存储和基本元数据提取。
- **任务拆解与步骤：**
    1. **文献模型与存储路径设计 (后端):**
        - **第一步：扩展数据库Schema。**
            - **作用：** 存储文献信息。
            - **步骤：** 定义 `Literature` 模型，包含 `id`, `title`, `author`, `abstract`, `file_path`, `group_id`, `uploaded_by_user_id`, `upload_date`。
            - **效果：** 数据库中有了文献的表结构。
        - **第二步：配置文件上传存储。**
            - **作用：** 确定文献文件存放位置。
            - **步骤：** 在FastAPI中，使用 `python-multipart` 处理文件上传。配置一个专用的文件存储目录 (例如 `uploads/`)，并为每个课题组创建子目录 (例如 `uploads/group_id/`)。
            - **效果：** 服务器端能够接收并按课题组ID组织存储上传的文献文件。
    2. **文件上传接口 (后端):**
        - **第一步：实现 `/literature/upload/{group_id}` POST接口。**
            - **作用：** 接收并处理文献文件上传。
            - **步骤：** 接口接收 `group_id` 作为路径参数，并使用 `File()` 接收上传的文件。验证当前用户是否是该 `group_id` 的成员。保存文件到指定路径。
            - **效果：** 只有课题组成员才能上传文件到其组的公共文献库。
        - **第二步：文献元数据提取与存储。**
            - **作用：** 从上传文件中提取关键信息并存入数据库。
            - **步骤：** 对于PDF文件，使用 `PyPDF2` (或更强大的 `pdfminer.six`) 提取文本内容，并尝试从文本中解析 `title`, `author`, `abstract` (简单正则或关键词匹配)。对于Word/HTML文件，MVP阶段可以仅存储文件，元数据留空或手动输入。将提取到的元数据和文件路径存入 `Literature` 表。
            - **效果：** 上传的文献文件及其元数据（部分）被存储到数据库。
    3. **公共文献库列表接口 (后端):**
        - **第一步：实现 `/literature/public/{group_id}` GET接口。**
            - **作用：** 获取特定课题组的公共文献列表。
            - **步骤：** 接收 `group_id`。查询数据库中属于该 `group_id` 的所有文献的元数据。
            - **效果：** 后端能够按课题组ID提供其公共文献列表。
    4. **前端上传UI与列表展示：**
        - **第一步：在公共文献库页面添加上传按钮。**
            - **作用：** 提供上传入口。
            - **步骤：** 在公共文献库的UI中，添加一个 `Upload` 按钮。
            - **效果：** 用户在公共文献库页面可以看到上传文献的按钮。
        - **第二步：实现文件选择和上传。**
            - **作用：** 允许用户选择并上传文件。
            - **步骤：** 点击上传按钮后，触发文件选择器。使用 `FormData` 封装文件并调用后端 `/literature/upload/{group_id}` 接口。
            - **效果：** 用户可以成功选择并上传文献文件到当前所在的公共文献库。
        - **第三步：显示公共文献列表。**
            - **作用：** 展示课题组内的所有共享文献。
            - **步骤：** 当用户进入公共文献库视图时，调用后端 `/literature/public/{group_id}` 接口获取文献列表，并在前端展示文献的标题、作者等信息。
            - **效果：** 用户可以看到其课题组内已上传的公共文献列表。

**Day 4: 文献查看 & AI核心搭建**

- **目标：** 实现用户在课题组内查看公共文献，并初步搭建AI问答的RAG管道。
- **任务拆解与步骤：**
    1. **文献服务接口 (后端):**
        - **第一步：实现 `/literature/view/file/{literature_id}` GET接口。**
            - **作用：** 提供文献文件的下载或流式服务。
            - **步骤：** 接收 `literature_id`。验证当前用户是否是该文献所属课题组的成员。从数据库获取文件路径，并使用FastAPI的 `FileResponse` 或流式传输文件。
            - **效果：** 后端能够安全地将文献文件传输到前端。
    2. **在线阅读器 (前端):**
        - **第一步：集成PDF查看器。**
            - **作用：** 在浏览器中展示PDF文件。
            - **步骤：** 安装 `react-pdf` (`npm install react-pdf`). 在Next.js中创建一个组件，接收文献ID，调用后端 `/literature/view/file/{literature_id}` 接口获取PDF数据，并使用 `Document` 和 `Page` 组件进行渲染。
            - **效果：** 用户双击文献列表中的PDF文献，可以在新的视图中看到PDF内容。
        - **第二步：处理Word/HTML文件 (MVP简化)。**
            - **作用：** 对非PDF文件提供基本处理。
            - **步骤：** 对于Word/HTML文件，MVP阶段可以仅提供下载链接，或在上传时尝试转换为PDF（如果时间允许）。
            - **效果：** 所有文献文件至少有下载或基本查看的途径。
    3. **AI浮动球UI (前端):**
        - **第一步：创建AI助手入口UI。**
            - **作用：** 提供AI助手的唤醒按钮。
            - **步骤：** 在文献阅读页面的右下角放置一个浮动的圆形按钮（AI浮动球）。点击时，展开一个占屏幕1/4大小的对话框。
            - **效果：** 用户在阅读文献时，可以看到并点击AI助手浮动球，对话框弹出。
    4. **文本分块与Embedding (后端AI):**
        - **第一步：配置Langchain和OpenAI API。**
            - **作用：** 准备AI核心工具。
            - **步骤：** `pip install langchain openai tiktoken chromadb`。在FastAPI项目中配置OpenAI API密钥。
            - **效果：** 后端能够调用OpenAI API和使用Langchain工具。
        - **第二步：实现文本分块逻辑。**
            - **作用：** 将长文本分割成适合Embedding模型处理的小块。
            - **步骤：** 在文献上传成功后，启动一个异步任务或在 `/literature/upload` 接口中调用一个服务。使用 `Langchain` 的 `RecursiveCharacterTextSplitter` 对从PDF中提取的文本进行分块。
            - **效果：** 文献内容被有效分割成可管理的块。
        - **第三步：生成并存储Embedding。**
            - **作用：** 将文本块转化为向量，并存储到向量数据库。
            - **步骤：** 对每个文本块，使用 `OpenAIEmbeddings` (Langchain提供) 生成embedding向量。将文本块、对应的向量以及其所属的 `literature_id` 和 `group_id` 存入 `ChromaDB` (或FAISS)。
            - **效果：** 文献的每个文本块都对应一个向量，并存储在向量数据库中，为后续检索准备。

**Day 5: AI助手集成 (问答功能)**

- **目标：** 连接AI助手UI到RAG管道，为当前查看的公共文献提供实时问答。
- **任务拆解与步骤：**
    1. **RAG问答接口 (后端AI):**
        - **第一步：实现 `/ai/ask` POST接口。**
            - **作用：** 接收用户问题并返回AI答案。
            - **步骤：** 接收 `question` (用户问题) 和 `literature_id` (当前查看文献ID)。
            - **效果：** 后端有了一个接受AI问答请求的入口。
        - **第二步：构建检索链。**
            - **作用：** 从向量数据库中检索相关文本块。
            - **步骤：** 使用 `Chroma.from_existing_persist` (如果ChromaDB是持久化的) 或加载FAISS索引。根据 `literature_id` 过滤检索范围，只在当前文献的向量中进行相似度搜索。
            - **效果：** AI能够根据用户问题，精确地从当前文献中找到最相关的文本片段。
        - **第三步：构建生成链。**
            - **作用：** 使用LLM根据检索到的文本块生成答案。
            - **步骤：** 使用 `ChatOpenAI` 作为LLM。将用户问题和检索到的相关文本块作为上下文，传递给LLM，要求其生成答案并指出引用来源。
            - **效果：** AI能够生成基于文献内容和用户问题的准确回答，并提供出处。
    2. **前端AI对话框交互：**
        - **第一步：实现对话框的输入和显示。**
            - **作用：** 提供用户输入问题和查看AI回答的界面。
            - **步骤：** 在AI对话框中添加一个文本输入框，并一个区域显示历史对话（用户问题和AI回答）。显示预设问题（如“总结核心论点”）。
            - **效果：** AI助手界面可以进行基本的文本交互。
        - **第二步：连接前端到后端AI接口。**
            - **作用：** 将用户输入发送到后端AI，并显示AI的响应。
            - **步骤：** 用户输入问题或点击预设问题时，调用后端 `/ai/ask` 接口，同时传递 `literature_id`。接收AI的响应并将其添加到对话历史中。
            - **效果：** 用户可以与AI助手进行交互，对当前文献提问并获得答案。
    3. **基本多轮对话支持：**
        - **第一步：在前端维护对话历史。**
            - **作用：** 确保AI能理解上下文。
            - **步骤：** 在前端状态中存储之前的用户问题和AI回答。
            - **效果：** 前端能够记录对话过程。
        - **第二步：后端传递历史对话。**
            - **作用：** 让LLM了解之前的对话上下文。
            - **步骤：** 在调用`/ai/ask`接口时，将前端维护的最近几轮对话历史（只包含用户问题和AI回答，不包含检索到的文档内容）也作为参数发送给后端。后端在调用LLM时，将这些历史对话作为`messages`的一部分传入。
            - **效果：** AI在回答后续问题时，会考虑到之前的对话内容。

**Day 6: 优化、测试与错误处理 (协作流程)**

- **目标：** 优化现有功能，进行基本测试，并实现必要的错误处理，重点关注协作相关的流程。
- **任务拆解与步骤：**
    1. **前端UI/UX优化：**
        - **第一步：细化界面样式。**
            - **作用：** 提升用户体验。
            - **步骤：** 统一登录、注册、课题组管理、文献列表和阅读器页面的样式，确保Shadcn/ui和TailwindCSS的充分利用，使界面美观且符合响应式设计。
            - **效果：** 应用界面更专业、更易用。
    2. **错误处理 (前端 & 后端 - 协作上下文):**
        - **第一步：后端错误响应标准化。**
            - **作用：** 便于前端统一处理。
            - **步骤：** 确保所有FastAPI接口在发生错误时都返回标准化的JSON错误响应 (例如 `{"detail": "错误信息", "code": 400}`).
            - **效果：** 前端能根据统一格式解析后端错误。
        - **第二步：前端错误信息展示。**
            - **作用：** 及时告知用户操作结果。
            - **步骤：** 在所有涉及API调用的地方（注册、登录、创建/加入课题组、上传文献、AI问答），捕获后端错误，并使用弹窗或表单下方文本提示用户（例如“该手机号已注册”、“ID或邀请码错误”）。
            - **效果：** 用户能及时收到操作反馈。
        - **第三步：添加后端日志。**
            - **作用：** 便于调试和问题追踪。
            - **步骤：** 在FastAPI中集成Python的 `logging` 模块，记录关键操作和错误信息。
            - **效果：** 后端运行状态和问题有记录可查。
    3. **单元与集成测试 (基础):**
        - **第一步：编写后端单元测试。**
            - **作用：** 验证核心业务逻辑的正确性。
            - **步骤：** 使用 `pytest` 为用户认证服务（注册、登录）、课题组服务（创建、加入）以及文献上传服务编写单元测试。
            - **效果：** 核心业务逻辑在代码层面得到初步验证。
        - **第二步：执行手动集成测试。**
            - **作用：** 模拟真实用户流程，验证端到端功能。
            - **步骤：** 至少使用两个用户账户，手动测试以下场景：
                - 用户A注册 -> 创建课题组A。
                - 用户B注册 -> 使用课题组A的ID和邀请码加入课题组A。
                - 用户A上传PDF文献到课题组A的公共文献库。
                - 用户B在课题组A的公共文献库中查看该文献。
                - 用户B对该文献使用AI进行问答。
                - 用户A也能看到并访问用户B上传的文献。
            - **效果：** 确保核心协作流程顺畅。
    4. **代码审查与文档：**
        - **第一步：内部代码审查。**
            - **作用：** 发现潜在问题，提高代码质量。
            - **步骤：** 团队成员之间互相审查核心模块代码。
            - **效果：** 代码质量得到初步提升。
        - **第二步：更新README文件。**
            - **作用：** 方便项目成员和未来接手者理解项目。
            - **步骤：** 更新前端和后端项目的 `README.md` 文件，包含项目设置、运行方式、API接口说明等。
            - **效果：** 项目文档清晰，便于后续开发。

**Day 7: MVP演示准备与部署**

- **目标：** 准备MVP演示，并进行基本的部署，展示协作功能。
- **任务拆解与步骤：**
    1. **最终测试与Bug修复：**
        - **第一步：全面E2E测试。**
            - **作用：** 确保所有MVP功能在不同场景下均正常工作。
            - **步骤：** 再次执行Day 6的集成测试，并扩展测试用例，确保所有用户流无阻碍。修复发现的任何临界bug。
            - **效果：** MVP达到可演示状态。
    2. **演示脚本与演练：**
        - **第一步：编写演示脚本。**
            - **作用：** 确保演示流程清晰、流畅，突出MVP亮点。
            - **步骤：** 撰写一个简短的演示脚本，强调课题组创建、加入、共享文献上传、共同查看和AI问答的协作场景。
            - **效果：** 演示有条理，能有效展示MVP价值。
        - **第二步：进行演示演练。**
            - **作用：** 确保演示顺利进行，提前发现并解决问题。
            - **步骤：** 团队内部进行多次演示演练，熟悉操作流程和可能出现的意外情况。
            - **效果：** 团队成员对演示内容和流程熟练掌握。
    3. **部署 (本地/基础云服务):**
        - **第一步：使用Docker Compose封装应用。**
            - **作用：** 确保开发和部署环境一致性。
            - **步骤：** 编写 `docker-compose.yml` 文件，包含Next.js前端、FastAPI后端和数据库（如PostgreSQL或SQLite）。
            - **效果：** 可以通过 `docker-compose up` 一键启动整个应用栈。
        - **第二步：考虑云服务部署 (可选但推荐)。**
            - **作用：** 使MVP可远程访问和演示。
            - **步骤：**
                - **前端：** 部署到Vercel (免费)。
                - **后端：** 部署到Render (免费层) 或其他支持Python/Docker的PaaS平台。
                - **数据库：** 如果使用持久化数据库（如PostgreSQL），考虑使用ElephantSQL的免费层。
            - **效果：** MVP具备可访问的公共URL，便于演示和分享。
    4. **反馈收集计划：**
        - **第一步：制定MVP反馈收集方式。**
            - **作用：** 为下一阶段开发提供指导。
            - **步骤：** 确定如何收集用户对MVP的反馈，例如简单的在线问卷或内部讨论会。
            - **效果：** 明确了MVP发布后的反馈收集路径。

---

### 风险管理与应急预案 (Python后端，协作重心)

- **Python库兼容性/版本问题：** 在Day 1和Day 4初期，务必锁定好 `requirements.txt` 中的库版本，避免后期出现不兼容。
- **文献解析复杂性：** 如果 `PyPDF2` 或 `python-docx` 在提取某些文献内容时遇到困难，MVP阶段可以接受不完美的结果，或者聚焦于标准格式的PDF文档进行演示。更高级的解析（如表格、图片识别）推迟。
- **AI响应速度/成本：** 密切关注OpenAI API的使用量和成本。MVP阶段使用 `text-embedding-3-small` 模型和低成本的LLM，并设置最大令牌数。如果响应速度慢，考虑缓存AI结果。
- **ChromaDB/FAISS持久化：** 确保向量数据库的持久化配置正确，避免服务重启后数据丢失。
- **协作实时性：** MVP不强制要求实时更新（如批注），但对于公共文献库列表更新，如果不能做到自动化刷新，可引导用户手动刷新页面。
- **测试覆盖率：** 在7天内不可能做到全面测试。专注于关键路径和高风险功能的测试，确保核心协作流程的稳定性。